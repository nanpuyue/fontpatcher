#!/usr/bin/env python3
# -*- coding utf-8 -*-

import argparse
import sys
import re
import os.path

try:
	import fontforge
	import psMat
except ImportError:
	sys.stderr.write('The required FontForge modules could not be loaded.\n\n')
	sys.stderr.write('You need FontForge with Python bindings for this script to work.\n')
	sys.exit(1)


def get_argparser(ArgumentParser=argparse.ArgumentParser):
	parser = ArgumentParser(
		description=('Font patcher for Powerline. '
		             'Requires FontForge with Python bindings. '
		             'Stores the patched font as a new, renamed font file by default.')
	)
	parser.add_argument('target_fonts', help='font files to patch', metavar='font',
	                    nargs='+', type=argparse.FileType('rb'))
	parser.add_argument('--no-rename',
	                    help='don\'t add " for Powerline" to the font name',
	                    default=True, action='store_false', dest='rename_font')
	parser.add_argument('--source-font', help='source symbol font', metavar='font',
	                    dest='source_font',
	                    default='{0}/../fonts/powerline-symbols.sfd'.format(sys.path[0]),
	                    type=argparse.FileType('rb'))
	return parser


FONT_NAME_RE = re.compile(r'^([^-]*)(?:(-.*))?$')


def patch_one_font(source_font, target_font, rename_font=True):

	# Rename font
	if rename_font:
		target_font.familyname += ' for Powerline'
		target_font.fullname += ' for Powerline'
		fontname, style = FONT_NAME_RE.match(target_font.fontname).groups()
		target_font.fontname = fontname + 'ForPowerline'
		if style is not None:
			target_font.fontname += style
		target_font.appendSFNTName(
			'English (US)', 'Preferred Family', target_font.familyname)
		target_font.appendSFNTName(
			'English (US)', 'Compatible Full', target_font.fullname)

	source_bb = source_font['block']
	target_bb = target_font['a']
	target_font_width = target_bb.width

	# Find source and target size difference for scaling
	x_ratio = target_bb.width / source_bb.width
	print('X: (0, %d) -> (0, %d)' % (source_bb.width, target_bb.width))
	y_ratio = (target_font.hhea_ascent - target_font.hhea_descent) / (source_font.hhea_ascent - source_font.hhea_descent)
	print('Y: (%d, %d) -> (%d, %d)' % (source_font.hhea_ascent, source_font.hhea_descent, target_font.hhea_ascent, target_font.hhea_descent))
	scale = psMat.scale(x_ratio, y_ratio)

	# Find source and target midpoints for translating
	y_diff = (target_font.hhea_ascent + target_font.hhea_descent) / 2 - (source_font.hhea_ascent + source_font.hhea_descent) * y_ratio / 2
	translate = psMat.translate(0, y_diff)
	transform = psMat.compose(scale, translate)

	# Create new glyphs from symbol font
	for source_glyph in source_font.glyphs():
		if source_glyph == source_font['block']:
			# Skip the symbol font block glyph
			continue

		# Select and copy symbol from its encoding point
		source_font.selection.select(source_glyph.encoding)
		source_font.copy()

		# Select and paste symbol to its unicode code point
		target_font.selection.select(source_glyph.unicode)
		target_font.paste()

		# Transform the glyph
		target_font.transform(transform)

		# Reset the font's glyph width so it's still considered monospaced
		target_font[source_glyph.unicode].width = target_font_width

	# Generate patched font
	extension = os.path.splitext(target_font.path)[1]
	if extension.lower() not in ['.ttf', '.otf']:
		# Default to OpenType if input is not TrueType/OpenType
		extension = '.otf'
	target_font.generate('{0}{1}'.format(target_font.fullname, extension))


def patch_fonts(source_file, target_files, rename_font=True):
	source_font = fontforge.open(source_file.name, 1)
	for target_file in target_files:
		target_font = fontforge.open(target_file.name, 1)
		try:
			patch_one_font(source_font, target_font, rename_font)
		finally:
			target_font.close()
	return 0


def main(argv):
	args = get_argparser().parse_args(argv)
	return patch_fonts(args.source_font, args.target_fonts, args.rename_font)


raise SystemExit(main(sys.argv[1:]))
